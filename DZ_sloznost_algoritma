# Алгоритм binary_search реализует классический бинарный поиск в отсортированном массиве.
# Давайте разберем его шаг за шагом и оценим временную сложность.
#
# Описание работы алгоритма:
# 1. Алгоритм начинает с двух индексов: low указывает на начало массива, а high — на конец.
# 2. В цикле он вычисляет средний индекс (mid) и сравнивает элемент массива с этим индексом с искомым значением (target).
#   * Если найден нужный элемент, алгоритм возвращает его индекс.
#   * Если элемент меньше искомого значения, то левая граница смещается вправо (low = mid + 1),
#   так как искомое значение может находиться справа от среднего элемента.
#   * Если элемент больше искомого значения, правая граница смещается влево (high = mid - 1),
#   поскольку искомый элемент находится слева от среднего.
# 3. Цикл продолжается до тех пор, пока левая граница не станет больше правой границы, после чего возвращается -1,
# означающее, что элемент не был найден.
#
# Временная сложность:
# Временная сложность этого алгоритма определяется количеством операций сравнения элементов массива с целевым значением.
# При каждом проходе цикла мы делим диапазон поиска пополам, уменьшая количество возможных вариантов вдвое.
#
# Оценка сложности:
# Для массива длины
# n
# n:
#
# На первом шаге у нас есть
# n
# n элементов для проверки.
# После первого деления остается
# n
# 2
# 2
# n
# ​
#   элементов.
# После второго деления остается
# n
# 4
# 4
# n
# ​
#   элементов.
# И так далее...
# Это деление происходит логарифмически, поэтому общее количество шагов равно
# log
# ⁡
# 2
# n
# log
# 2
# ​
#  n. Это означает, что временная сложность бинарного поиска составляет
# O
# (
# log
# ⁡
# n
# )
# O(logn).
#
# Таким образом, временная сложность данного алгоритма равна
# O
# (
# log
# ⁡
# n
# )
# O(logn).# Алгоритм binary_search реализует классический бинарный поиск в отсортированном массиве.
# Давайте разберем его шаг за шагом и оценим временную сложность.
#
# Описание работы алгоритма:
# 1. Алгоритм начинает с двух индексов: low указывает на начало массива, а high — на конец.
# 2. В цикле он вычисляет средний индекс (mid) и сравнивает элемент массива с этим индексом с искомым значением (target).
#   * Если найден нужный элемент, алгоритм возвращает его индекс.
#   * Если элемент меньше искомого значения, то левая граница смещается вправо (low = mid + 1),
#   так как искомое значение может находиться справа от среднего элемента.
#   * Если элемент больше искомого значения, правая граница смещается влево (high = mid - 1),
#   поскольку искомый элемент находится слева от среднего.
# 3. Цикл продолжается до тех пор, пока левая граница не станет больше правой границы, после чего возвращается -1,
# означающее, что элемент не был найден.
#
# Временная сложность:
# Временная сложность этого алгоритма определяется количеством операций сравнения элементов массива с целевым значением.
# При каждом проходе цикла мы делим диапазон поиска пополам, уменьшая количество возможных вариантов вдвое.
#
# Оценка сложности:
# Для массива длины
# n
# n:
#
# На первом шаге у нас есть
# n
# n элементов для проверки.
# После первого деления остается
# n
# 2
# 2
# n
# ​
#   элементов.
# После второго деления остается
# n
# 4
# 4
# n
# ​
#   элементов.
# И так далее...
# Это деление происходит логарифмически, поэтому общее количество шагов равно
# log
# ⁡
# 2
# n
# log
# 2
# ​
#  n. Это означает, что временная сложность бинарного поиска составляет
# O
# (
# log
# ⁡
# n
# )
# O(logn).
#
# Таким образом, временная сложность данного алгоритма равна
# O
# (
# log
# ⁡
# n
# )
# O(logn).