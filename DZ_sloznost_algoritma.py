def binary_search(arr, target):
    low, high = 0, len(arr) - 1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return -1

arr = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
print(binary_search(arr, 70))
print(binary_search(arr, 25))

# *********************************************************
# Алгоритм, представленный здесь, является бинарным поиском. Давайте оценим его временную и пространственную сложность.
#
# Временная сложность:
# Бинарный поиск работает на отсортированном массиве, разделяя его пополам на каждом шаге.
# На каждом шаге алгоритм исключает половину элементов из рассмотрения, что делает его сложность логарифмической.
#
# В худшем случае, количество операций сокращается до половины массива на каждом шаге.
# Количество шагов, необходимых для достижения элемента или обнаружения его отсутствия,
# равно log2(n), где n — количество элементов в массиве.
# Временная сложность:𝑂(log n)
#
# Пространственная сложность:
# Алгоритм использует фиксированное количество дополнительных переменных
# (low, high, mid). Он не требует дополнительной памяти, пропорциональной размеру входных данных,
# так как все вычисления происходят в пределах исходного массива.
#
# Пространственная сложность:𝑂(1).

# Вывод:
# * Временная сложность:𝑂(log n)
# * Пространственная сложность:𝑂(1).
#
# Таким образом, бинарный поиск является эффективным алгоритмом для поиска в отсортированных массивах.
